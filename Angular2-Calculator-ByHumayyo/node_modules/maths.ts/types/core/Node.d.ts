/**
 * Inside the expressions, whenever numberPattern matches a string, it will be
 * considered as a number.
 */
export declare const numberRegex: RegExp;
/**
 * Inside the expressions, whenever symbolPattern matches a string, it will be
 * considered as a symbol.
 */
export declare const symbolRegex: RegExp;
/**
 * The types the Node class accepts for performing its operations from
 * creating the Node to adding, etc.
 */
export declare type ValidNumber = number | string | Node;
/**
 * Node represents the basic tree node class. Any implementation of a tree
 * expression must be extended through Node internally.
 */
export default class Node {
    parent: Node;
    static scope: any;
    children: Node[];
    exponent: Node | number;
    type: NodeType;
    value: number | string;
    /**
     * Builds the tree for expression.
     * @param exp The expression to be represented with this.
     * @param parent The parent for this Node.
     */
    constructor(exp?: ValidNumber, parent?: Node);
    /**
     * Access the operators in Node's scope.
     * @return The operators in the scope.
     */
    static readonly operators: any;
    /**
     * Access the functions in Node's scope.
     * @return The functions in the scope.
     */
    static readonly functions: any;
    /**
     * Access the constants in Node's scope.
     * @return The constants in the scope.
     */
    static readonly constants: any;
    private _positive;
    /**
     * Returns whether this is positive or not.
     * @return true if this is positive, false otherwise.
     */
    /**
     * Sets the sign of this.
     */
    positive: boolean;
    readonly isFraction: boolean;
    /**
     * Calculates the value of this Node as a number type. If this contains
     * an element that cannot be converted to a number it will return undefined.
     * @return The value of this as a number.
     */
    readonly numberValue: number;
    /**
     * Returns whether this is positive or not.
     * @return true if this is positive, false otherwise.
     */
    /**
     * Sets the sign of this.
     */
    negative: boolean;
    /**
     * Creates a new Node from the given expression.
     * @param exp The expression from where to create the node.
     * @return A new node representing the expression.
     */
    static newNode(exp?: ValidNumber): Node;
    /**
     * Returns a new Node representing the addition of a plus b.
     * @param a A number to add.
     * @param b A number to add.
     * @return new Node(a + b).
     */
    static add(a: ValidNumber, b: ValidNumber): Node;
    /**
     * Returns a new Node representing the multiplication of a times b.
     * @param a A number to multiply.
     * @param b A number to multiply.
     * @return new Node(a * b).
     */
    static multiply(a: ValidNumber, b: ValidNumber): Node;
    /**
     * Adds a constant to the scope.
     * @param c The constant to be added.
     * @param v The value the constant will get.
     */
    static setConstant(c: string, v: number): void;
    /**
     * Gets the value as a number for this node. In the event that there is
     * a variable in this expression, that variable must be declared in the
     * global scope or sent through the scope param in order to interpret
     * the variable in the expression, if a variable has no number value in
     * scope then the value returned will be undefined.
     * @param lScope The scope in which some variables inside this will be
     * evaluated.
     * @return The value for this according to the scope provided. In the
     * event that a variable is missed in the scope it will return undefined.
     */
    getNumberValue(lScope?: any): number;
    /**
     * Adds to this another value in a new Node.
     * @param s The expression to operate with.
     * @return A new Node with the value of this plus s.
     */
    add(s: ValidNumber): Node;
    /**
     * Subtracts to this another value in a new Node.
     * @param s The expression to operate with.
     * @return A new Node with the value of this minus s.
     */
    subtract(s: ValidNumber): Node;
    /**
     * Multiplies to this another value in a new Node.
     * @param s The expression to operate with.
     * @return A new Node with the value of this times s.
     */
    multiply(s: ValidNumber): Node;
    /**
     * Divides to this another value in a new Node.
     * @param s The expression to operate with.
     * @return A new Node with the value of this between s.
     */
    divide(s: ValidNumber): Node;
    /**
     * Powers to this another value in a new Node.
     * @param s The expression to operate with.
     * @return A new Node with the value of this pow s.
     */
    pow(s: ValidNumber): Node;
    /**
     * Creates a new node equivalent to -this.
     * @return A negation of this.
     */
    negate(): Node;
    /**
     * Adds to this another value and keeps the result in this Node.
     * @param s The expression to operate with.
     */
    addHere(s: ValidNumber): Node;
    /**
     * Subtracts to this another value and keeps the result in this Node.
     * @param s The expression to operate with.
     */
    subtractHere(s: ValidNumber): Node;
    /**
     * Multiplies to this another value and keeps the result in this Node.
     * @param s The expression to operate with.
     */
    multiplyHere(s: ValidNumber): Node;
    /**
     * Divides to this another value and keeps the result in this Node.
     * @param s The expression to operate with.
     */
    divideHere(s: ValidNumber): Node;
    /**
     * Powers to this another value in a new Node.
     * @param s The expression to operate with.
     * @return A new Node with the value of this pow s.
     */
    powHere(s: ValidNumber): Node;
    /**
     * Changes this node's sign.
     */
    negateHere(): Node;
    /**
     * Compare this and other number with the given operator.
     * @param n The number which to compare this.
     * @param operator The operator to compare this with n.
     * @return this {operator} n.
     */
    compare(n: Node | number, operator?: string): boolean;
    /**
     * Converts this to a string.
     * @return The string that represents this.
     */
    toString(): string;
    /**
     * Creates a copy of this Node.
     * @return A copy of this Node.
     */
    clone(): Node;
    /**
     * Checks if this is Not a Number.
     * @return true if this is NaN, false otherwise.
     */
    isNaN(): boolean;
    /**
     * Simplifies each children of this, then simplifies this. At this
     * moment simplify uses a very simple simplification that is yet waiting
     * to be completed.
     */
    simplify(): void;
    /**
     * Whenever this.value is a number, it may be seen as a rational number.
     * If it has a decimal point then it is better to represent that value
     * as a fraction in order to keep accuracy on later operations.
     * Rationalize transforms this node to a fraction if this.value is a non
     * integer number.
     */
    rationalize(): void;
    /**
     * Updates this to a new value or type of node.
     * @param n The new value.
     */
    update(n: number | Node): void;
    /**
     * Prints the child sent with or without parentheses according to this
     * operator's priority.
     * @param n The child to be printed.
     * @return The string as how n should be printed.
     */
    private printChild(n);
    /**
     * Simplifies this when it is a division.
     */
    private simplifyDivision();
    /**
     * Simplifies this when it is a product.
     */
    private simplifyProduct();
    /**
     * Simplifies this when it is a division.
     */
    private simplifyAddition();
    /**
     * Simplifies this when it is a product.
     */
    private simplifySubtraction();
}
/**
 * Represents the types which a Node can represent. The nodes can only be
 * operators, constants, functions or variables. Each one of this node types
 * have their own features that distinguish them from the others.
 */
export declare enum NodeType {
    Operator = 0,
    Constant = 1,
    Function = 2,
    Variable = 3,
}
