"use strict";
/**
 * @author Hector J. Vasquez <ipi.vasquez@gmail.com>
 *
 * @licence
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Edge_1 = require("./Edge");
const Vertex_1 = require("./Vertex");
/**
 * Represents a graph as an adjacency list. It provides methods for
 * adding/removing vertex and edges.
 */
class Graph {
    /**
     * Builds a graph with or without vertex.
     * TODO: neighbor and graph function generators.
     * @param nVertexes The initial number of vertexes for this.
     * @param directed Indicates if the graph is going to be a directed
     * graph or not.
     */
    constructor(nVertexes, directed = false) {
        this.directed = directed;
        // TODO: There may be a better way to built a graph, I think.
        this._vertexes = [];
        this.directed = directed;
        for (let i = 0; i < nVertexes; i++) {
            this.addVertex();
        }
    }
    /**
     * Gets the vertex in this graph.
     * @return The vertexes of this graph.
     */
    get vertexes() {
        return this._vertexes;
    }
    /**
     * Gets all edges from Graph.
     * @return The edges of this graph.
     */
    get edges() {
        const es = [];
        this.vertexes.forEach((v) => v.edges.forEach((e) => es.push(e)));
        return es;
    }
    /**
     * Adds a vertex to this graph.
     * @param name The name for the new vertex.
     * @param info Additional name about the vertex.
     */
    addVertex(name, info) {
        this.vertexes.push(new Vertex_1.default(this.vertexes.length, name, info));
    }
    /**
     * Builds an edge, then adds it to the source vertex.
     * @param from
     * @param to
     * @param weight
     * @param info
     */
    addEdge(from, to, weight, info) {
        this.vertexes[from].addEdge(new Edge_1.default(this.vertexes[from], this.vertexes[to], weight, info));
        if (!this.directed) {
            this.vertexes[to].addEdge(new Edge_1.default(this.vertexes[to], this.vertexes[from], weight, info));
        }
    }
    /**
     * Returns the value gotten from evaluating a given heuristic with given
     * source and destination.
     * @param s The source.
     * @param d The destination.
     * @return {number} The distance between them according to the heuristic
     * defined on this graph.
     */
    heuristicValue(s, d) {
        if (this._heuristic) {
            return this._heuristic(this.vertexes[s], this.vertexes[d]);
        }
        return 0;
    }
    /**
     * Sets a heuristic for this graph.
     * @param h The new heuristic.
     */
    setHeuristic(h) {
        this._heuristic = h;
    }
    /**
     * Prints this graph vertex and adjacency list.
     */
    toString() {
        if (this._vertexes.length <= 0) {
            return 'Empty graph';
        }
        return 'Graph:\n\t' + this.vertexes.join('\n\t');
    }
}
exports.default = Graph;
