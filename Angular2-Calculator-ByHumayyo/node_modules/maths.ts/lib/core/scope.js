"use strict";
/**
 * @author Hector J. Vasquez <ipi.vasquez@gmail.com>
 *
 * @licence
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Error_1 = require("./Error");
/**
 * Defines the operators available.
 */
exports.operators = {
    '+': {
        priority: 1,
        params: 2,
        fn: (nodeA, nodeB, scope) => {
            const a = nodeA.getNumberValue(scope), b = nodeB.getNumberValue(scope);
            if (a !== undefined && b !== undefined) {
                return a + b;
            }
            return undefined;
        }
    },
    '-': {
        priority: 1,
        params: 2,
        fn: (nodeA, nodeB, scope) => {
            const a = nodeA.getNumberValue(scope), b = nodeB.getNumberValue(scope);
            if (a !== undefined && b !== undefined) {
                return a - b;
            }
            return undefined;
        }
    },
    '*': {
        priority: 2,
        params: 2,
        fn: (nodeA, nodeB, scope) => {
            const a = nodeA.getNumberValue(scope), b = nodeB.getNumberValue(scope);
            if (a !== undefined && b !== undefined) {
                return a * b;
            }
            return undefined;
        }
    },
    '/': {
        priority: 2,
        params: 2,
        fn: (nodeA, nodeB, scope) => {
            const a = nodeA.getNumberValue(scope), b = nodeB.getNumberValue(scope);
            if (a !== undefined && b !== undefined) {
                return a / b;
            }
            return undefined;
        }
    },
    '^': {
        priority: 3,
        params: 2,
        fn: (nodeA, nodeB, scope) => {
            const a = nodeA.getNumberValue(scope), b = nodeB.getNumberValue(scope);
            if (a !== undefined && b !== undefined) {
                return Math.pow(a, b);
            }
            return undefined;
        }
    },
    '!': {
        priority: 4,
        params: 1,
        fn: (node, scope) => {
            let aux;
            if ((aux = node.getNumberValue(scope)) !== undefined) {
                return fact(aux);
            }
            return aux;
            function fact(i) {
                if (i < 0 || Math.floor(i) === i) {
                    throw new Error_1.InputError('At this moment we are only capable to calculate ' +
                        'positive integers[0, inf).'); // TODO: factorial function (Gamma)
                }
                if (i < 2) {
                    return 1;
                }
                return i * fact(i - 1);
            }
        }
    }
};
/**
 * Defines the functions available.
 */
exports.functions = {
    sin: {
        fn: (node, scope) => {
            let aux;
            if ((aux = node.getNumberValue(scope)) !== undefined) {
                return Math.sin(aux);
            }
            return aux;
        }
    },
    cos: {
        fn: (node, scope) => {
            let aux;
            if ((aux = node.getNumberValue(scope)) !== undefined) {
                return Math.cos(aux);
            }
            return aux;
        }
    },
    tan: {
        fn: (node, scope) => {
            let aux;
            if ((aux = node.getNumberValue(scope)) !== undefined) {
                return Math.tan(aux);
            }
            return aux;
        }
    },
    asin: {
        fn: (node, scope) => {
            let aux;
            if ((aux = node.getNumberValue(scope)) !== undefined) {
                return Math.asin(aux);
            }
            return aux;
        }
    },
    acos: {
        fn: (node, scope) => {
            let aux;
            if ((aux = node.getNumberValue(scope)) !== undefined) {
                return Math.acos(aux);
            }
            return aux;
        }
    },
    atan: {
        fn: (node, scope) => {
            let aux;
            if ((aux = node.getNumberValue(scope)) !== undefined) {
                return Math.atan(aux);
            }
            return aux;
        }
    },
    log: {
        fn: (node, scope) => {
            let aux;
            if ((aux = node.getNumberValue(scope)) !== undefined) {
                return Math.log(aux);
            }
            return aux;
        }
    }
};
/**
 * Defines the constants available.
 */
exports.constants = {
    e: Math.E,
    pi: Math.PI,
    PI: undefined,
    E: undefined
};
exports.constants.E = exports.constants.e;
exports.constants.PI = exports.constants.pi;
